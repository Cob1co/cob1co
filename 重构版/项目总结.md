# 微电网三阶段控制项目总结（重构版）

本文档总结当前“重构版”项目的一至三阶段整体思路与实现方法，帮助后来者快速理解整个系统的结构与核心逻辑。

---

## 一、项目总体目标

在已有的物理模型与历史数据基础上，构建一个**分阶段演进**的微电网能量管理系统：

1. **第一阶段（Phase 1：物理+规则/启发式优化）**
   - 目标：基于系统物理模型和经济性指标，构建一个可解释的基线调度方案（类似 SA-MBPS）。
   - 关注点：设备容量配置、运行成本、弃电、购售电等年度经济性指标。

2. **第二阶段（Phase 2：多专家强化学习 SAC）**
   - 目标：在不同典型日/典型天气场景下，用 SAC 训练多个“专家策略”，分别擅长于不同工况。
   - 关注点：通过 K-means 聚类划分典型场景；在每个场景内用 RL 提升调度策略的收益。

3. **第三阶段（Phase 3：Transformer + MPC 的动态权重控制）**
   - 目标：在存在预测误差、场景变化等不确定性的背景下，
     - 结合 Phase 2 的专家参考轨迹；
     - 用 MPC 做实时优化微调；
     - 用 Transformer 学习在不同误差/天气下如何**动态调整 MPC 的权重（即“给 MPC 多大权限”）**，实现更智能的权衡策略。

最终得到一个：

> **“天气/场景 → 专家参考策略 → Transformer 给权重 → MPC 实时控制”** 的多层闭环控制体系。

---

## 二、数据与物理模型基础

### 2.1 历史与预测数据

- 历史数据：`data/data2023.csv`
  - 列包括：`Time`, `Load_kW`, `Solar_W_m2`, `Wind_Speed_m_s`, `Price_CNY_kWh` 等。
  - 供 K-means 聚类、Phase 2 训练、Phase 3 Oracle 数据收集等使用。

- 实时测试数据：`data/realtime2024.csv`
  - 用于 Phase 3 系统级评估，模拟 2024 年的实际运行。

- 预测数据：
  - 2023 训练期预测：`data/forecast_2023_8h_training.pkl`
  - 2024 测试期预测：`LMPC/data/forecast_2024_8h_testing.pkl`
  - 每个时间步 t，都有从 t 开始往后 8 小时（32 步）的负荷/光伏/风速/电价预测，
    实现典型的滚动预测结构。

### 2.2 物理模型与参数

- 物理模型早期实现集中在根目录 `models/` 下：
  - `pv.py`, `wind.py`, `thermal_storage.py`, `electric_heater.py`, `steam_turbine.py` 等。
  - 全局参数集中在 `models/config.yaml`：
    - 设备效率（电加热器、汽轮机等）；
    - 储热损失率；
    - 设备容量等。

- Phase 2 的环境（`SAC/microgrid_env.py`）与 Phase 3 的 MPC 与 ExpertInterface，
  均通过配置文件从 `models/config.yaml` 中**继承/对齐**关键物理参数，
  以保证三阶段所基于的“物理真值”一致。

---

## 三、第一阶段：场景聚类与物理+启发式优化（SA-MBPS）

（本阶段在重构版中主要作为背景和物理参数的定义来源，详细算法在 `SA-MBPS/` 与 `models/` 中。）

### 3.1 典型日场景聚类（K-means）

- 文件：`K-means/data_adapter.py`
- 输入：`data/data2023.csv`
  - 先按天切分数据（24 小时为一日）；
  - 只保留完整 24 小时的数据天数。

- 对每个完整的日数据 `day_df` 提取 10 维特征：
  1. 均值：光照、风速、负荷
  2. 标准差：光照、风速、负荷
  3. 峰值：光照、风速、负荷
  4. 电价均值

- 使用 `KMeans(n_clusters=5)` 对 365 天进行聚类：
  - 得到每一天的 `Day_Label ∈ {0,1,2,3,4}`；
  - 保存为 `K-means/clustered_data.csv`；
  - 同时保存训练好的 K-means 模型为 `K-means/kmeans_model.pkl`。

> 这一步的场景划分（典型日聚类）在 Phase 2 与 Phase 3 中被**复用**：
> - Phase 2：用 `Day_Label` 划分数据，训练各个 SAC 专家；
> - Phase 3：用同一个 `kmeans_model.pkl` 对实时/历史窗口进行分类，
>   以选择对应的 SAC 专家。

### 3.2 Phase 1 核心（简要）

- 通过 SA-MBPS 及 `models/` 里的物理模型，对微电网进行年度/长期运行模拟；
- 在一定规则/启发式控制和经济性评价指标下，给出一个**可解释的基线调度策略**。

在重构版中，Phase 1 更多作为：

- 物理参数的权威来源（经 `models/config.yaml` 下沉到 Phase2/3 配置）；
- 对比 Phase 2 / Phase 3 性能的“静态基线参考”。

---

## 四、第二阶段：多专家 SAC 策略

### 4.1 环境与配置

- 环境：`SAC/microgrid_env.py`
  - 状态维度：6 维
    - 负荷 (归一化)
    - 光伏出力 (归一化)
    - 风电出力 (归一化)
    - 储能 SOC
    - 电价 (归一化)
    - 上一时刻电网功率 (归一化)
  - 动作维度：1 维连续动作 ∈ [-1, 1]
    - >0：充电（电加热器）；
    - <0：放电（汽轮机）。
  - 奖励：运行成本 + 电网功率波动 + SOC 越界惩罚的组合，
    通过加权组合形成单一标量奖励。

- 环境物理：
  - 使用 `models/config.yaml` 或 Phase2 配置中的容量与效率参数，
    以 1 小时步长进行能量平衡与储能状态更新；
  - 内部包括弃电、购电/售电、SOC 损耗等详细逻辑。

### 4.2 聚类与专家训练

- 通过 `K-means/clustered_data.csv` 的 `Day_Label` 将数据划分为 5 类典型日；
- 针对每一类典型日，构建一个 `MicrogridEnv` 环境，训练一个 SAC 专家：
  - 专家 0：擅长某一类天气/负荷模式；
  - 专家 1：擅长另一类模式；
  - ……

- SAC 智能体实现：`SAC/sac_agent.py`
  - `PolicyNet`：Actor 网络，输出 1 维动作的高斯分布（均值+方差），再经过 tanh 映射至 [-1,1]；
  - `QValueNet`：Critic 网络，评估 Q(s,a)；
  - `SACAgent`：
    - 包含两个 Critic + 一个 Actor + 熵系数 α 自动调节；
    - 提供 `take_action`, `update`, `save`, `load` 等接口。

- 训练完成后，5 个专家模型（Actor+Critic）分别保存至 `SAC/models/expert_i_*.pth`。

### 4.3 专家接口（Phase 2 → Phase 3 的桥梁）

- 文件：`LMPC/core/expert_interface.py`

- 主要功能：
  - 从 `SAC/models` 加载所有专家的 Actor 网络；
  - 对任意当前状态 + 未来 8 小时预测，生成一条 8 小时、15 分钟分辨率的参考轨迹：
    - `soc_ref[0..31]`，`grid_ref[0..31]`。

- 关键方法：
  - `_generate_plan(expert_id, state, forecast_8h)`：
    - 每 15 分钟调用一次对应专家的 SAC 策略（deterministic）；
    - 通过与 Phase2 一致的物理推进 `_physics_step` 生成完整 8 小时参考轨迹。
  - `_smooth_transition(old_plan, new_plan)`：
    - 当专家切换时，对前 `transition_window`（默认 4 步 ≈ 1 小时）的参照轨迹做线性插值，
      以避免参考轨迹骤变。


---

## 五、第三阶段：Transformer + MPC 的动态权重控制

### 5.1 场景识别与专家选择（WeatherClassifier）

- 文件：`LMPC/core/weather_classifier.py`
- 职责：
  - 加载 K-means 聚类模型（优先从 `phase3_config.yaml.models.kmeans_model`，其后从 `K-means/kmeans_model.pkl`）；
  - 从任意一个时间序列 DataFrame（历史或预测）中提取 10 维特征；
  - 用 `kmeans.predict` 得到 label，作为 `expert_id`（与 Phase2 完全一致）。

- 特征设计（与 K-means 完全对齐）：
  1. 光照/风速/负荷 均值
  2. 光照/风速/负荷 标准差
  3. 光照/风速/负荷 峰值
  4. 电价均值

- 为避免原始数据缺测引入 NaN：
  - `_safe_mean/_safe_std/_safe_max` 对**空列或全 NaN 窗口**返回 0；
  - 确保传给 KMeans 的特征向量永远不含 NaN。

### 5.2 MPC 控制器（硬控制层）

- 文件：`LMPC/core/mpc_controller.py`
- 结构：
  - 时间步长：默认 15 分钟（`mpc.time_step_minutes`）；
  - 预测域：默认 32 步（8 小时）；
  - 控制变量：
    - 储能功率 `P_s[k]`（MW，充>0，放<0）；
    - 弃电功率 `P_curt[k]`；
    - 电网功率 `P_grid[k]`，以及其分解 `P_import[k], P_export[k]`。
  - 状态变量：储能 SOC `soc[k]`。

- 约束：
  - 储能能量平衡：`soc[k+1] = soc[k] + eta_storage * P_s[k] * dt / E_cap`；
  - 功率平衡：`P_grid = Load - PV - Wind + P_s + P_curt`；
  - P_grid 分解成导入/导出：`P_grid = P_export - P_import`；
  - SOC、P_s、P_grid、P_curt、P_import、P_export 的上下限约束。

- 目标函数（与需求文档一致）：

  \[
  J = \sum_k \Big(
      w_{soc} \cdot (soc_k - soc_k^{ref})^2
    + w_{grid} \cdot (P_{grid,k} - P_{grid,k}^{ref})^2
    + w_{cost} \cdot price_k \cdot P_{import,k} \cdot dt
    + w_{ramp} \cdot (P_{grid,k+1} - P_{grid,k})^2
    + w_{curt} \cdot P_{curt,k}
  \Big)
  \]

  其中：

  - `w_soc, w_grid, w_cost` 由**基础权重**与**动态系数 α**共同决定：
    - `w_soc  = w_soc_base  * alpha_soc`
    - `w_grid = w_grid_base * alpha_grid`
    - `w_cost = w_cost_base * alpha_cost`
  - `w_ramp, w_curt` 为固定权重。

> 也就是说，**Transformer 输出的 `(alpha_soc, alpha_grid, alpha_cost)` 决定了 MPC 在“跟踪专家参考轨迹”与“追求经济性”之间的权衡权重，
> 相当于在不同场景下动态调整“给 MPC 多大自由度、给专家多大话语权”。**


### 5.3 Transformer 权重控制器

- 文件：`LMPC/core/transformer_controller.py`
- 模型结构 `TransformerBackbone`：
  - 输入：`(batch, 24, 12)` 的特征序列，即过去 6 小时的 24 步、12 维特征。
  - 主干：标准 Transformer Encoder（多层 self-attention + feedforward）。
  - 输出头：MLP 输出 3 维；通过 Sigmoid + 线性缩放映射到 `[alpha_min, alpha_max]` 区间。

- 控制封装 `TransformerController`：
  - 负责加载 `LMPC/models/transformer_weights.pth`；
  - 提供 `predict_weights(state_seq)` 接口，输出：
    - `{'alpha_soc', 'alpha_grid', 'alpha_cost'}`；
  - 内部带有一阶低通滤波，平滑权重变化：
    - `filtered = a * raw + (1-a) * prev_weights`。


### 5.4 Oracle 数据收集（DataCollector）

- 文件：`LMPC/training/data_collector.py`
- 目标：
  - 在 2023 年的历史数据 + 预测数据基础上，
    利用固定的“真实评价函数 J_true”搜索每个时刻下最优的一组 `(alpha_soc, alpha_grid, alpha_cost)`；
  - 构造 Transformer 的监督训练数据集：

    - 输入：过去 24 步 × 12 维的状态/特征序列；
    - 标签：最优权重 `(alpha_soc, alpha_grid, alpha_cost)`。

- 关键思想：**“既不让 MPC 自己当裁判，又用真实世界评价权重”**

  1. 对每个时间步 t：
     - 用 `WeatherClassifier` + `ExpertInterface` 得到 8 小时参考计划 `soc_ref`, `grid_ref`；
     - 用特征提取器构造 24×12 的特征序列（包括预测误差统计等）。

  2. 对所有候选权重组合 `(alpha_soc, alpha_grid, alpha_cost)`（例如 {0.7,1.0,1.3}^3）：
     - 在**预测世界**里：
       - 调用 `MPCController.solve` 得到储能功率计划 `P_storage_plan` 等；
     - 在**真实世界**里：
       - 用 `_simulate_real_trajectory` + 真实 `Load/PV/Wind/Price` + 物理截断，
         以滚动方式推进真实 SOC、真实 P_grid、P_import；
       - 根据固定的 `J_true` 对整个 H 步真实轨迹打分（包括 SOC 跟踪、电网跟踪、经济成本、ramp、SOC 越界惩罚等）；

  3. 从所有候选权重中，选 J_true 最小的那一组 α 作为该时间步的**标签**。

这样得到的训练集具有如下性质：

- J_true 是独立于 MPC 的固定“终极裁判”，
  MPC 只是“在给定 α 和预测的前提下表现好坏”的选手；
- Transformer 学习到的 α，是“在各种预测误差和场景下，为了在真实世界获得较好 J_true，需要怎样分配 SOC 跟踪 / 电网跟踪 / 成本 的权重”；
- 避免了“既当运动员又当裁判员”的逻辑悖论。

---

## 六、Transformer 训练与 Phase 3 评估

### 6.1 Transformer 训练

- 训练脚本：`LMPC/training/train_transformer.py`
- 训练数据：`data/transformer_training_data.pkl`
  - 通过 `tests/run_data_collection_march.py` 或 `tests/run_data_collection_2023_full.py` 收集：
    - 3 月单月版 / 2023 全年版。
  - 每条样本格式：
    - `state_sequence`: `(24, 12)`
    - `optimal_weights`: `(3,)`（对应 α_soc, α_grid, α_cost）

- 模型与优化：
  - 使用与在线推理相同的 `TransformerBackbone`；
  - 损失函数：MSELoss，直接回归 3 维权重；
  - 优化器、学习率、batch size、早停等超参数由 `phase3_config.yaml` 中 `transformer.training` 配置；
  - 训练/验证集按 8:2 随机划分，带 patience 的早停；
  - 最优模型权重保存为 `LMPC/models/transformer_weights.pth`。


### 6.2 Phase 3 系统级评估

- 评估脚本：`tests/evaluate_system.py`
- 数据：
  - 实时数据：`data/realtime2024.csv`
  - 8 小时预测：`LMPC/data/forecast_2024_8h_testing.pkl`

- 两条评估路径：

  1. **基线（固定权重 MPC）**
     - 天气分类 → 选专家 → `ExpertInterface` 给 8 小时参考轨迹；
     - `dynamic_weights=None`，MPC 内部使用 α=1.0 的固定权重；
     - 滚动多天，记录 SOC、P_grid、代价和误差指标。

  2. **Phase 3（Transformer 动态权重 + MPC）**
     - 同样的天气分类和专家参考；
     - 维护 24 步特征序列，调用 `TransformerController.predict_weights` 得到 `(α_soc, α_grid, α_cost)`；
     - 把这些 α 传给 `MPCController.solve(..., dynamic_weights=weights)`；
     - 对比与参考轨迹的误差和整体代价，计算指标。

- 输出指标包括（但不限于）：
  - 总成本
  - SOC 跟踪误差
  - 电网功率跟踪误差
  - 电网功率波动（差分标准差）

- 在只用 3 月数据训练的初版模型上，已经在 2024‑02 的 7 天测试中观测到：
  - 综合目标（MPC 目标函数）成本约 **4.5% 降低**；
  - SOC 跟踪误差基本不变；
  - 电网波动略有改善；
  - 电网跟踪误差略有牺牲（合理的 trade-off）。

这表明：

> 在存在预测误差与多目标权衡的复杂场景下，Phase 3 框架已经能学会在“听专家”与“给 MPC 自由度”之间做更聪明的动态选择，从而在保持安全和稳定性的前提下，进一步降低运行成本。

---

## 七、整体架构小结

从整体来看，当前重构版项目实现了一个清晰的分层架构：

1. **物理与场景层（Phase 1 + models + K-means）**
   - 定义了统一的设备参数和物理行为；
   - 用 K-means 把全年数据划分为若干典型场景，为后续专家与控制策略提供“天气/负荷标签”。

2. **专家策略层（Phase 2 / SAC）**
   - 针对不同场景，各自学习一个强化学习专家策略；
   - 提供“8 小时参考轨迹”作为 Phase 3 的上游建议。

3. **实时控制层（Phase 3 / Weather + Expert + Transformer + MPC）**
   - WeatherClassifier：实时识别天气/场景，选择对应专家；
   - ExpertInterface：给出未来 8 小时的 SOC / P_grid 参考轨迹；
   - Transformer：根据历史特征与预测误差信息，输出动态权重 α；
   - MPCController：在这些权重与参考轨迹下做凸优化，生成实际控制量；
   - DataCollector + Oracle：用真实世界 J_true 评价不同 α 的好坏，为 Transformer 提供监督标签。

整个体系连接起了：

- **物理模型 → 场景聚类 → 强化学习专家 → MPC 优化 → 深度网络权重调度**，
  形成一个完整的、可扩展的微电网调度智能控制平台。

---

（完）
